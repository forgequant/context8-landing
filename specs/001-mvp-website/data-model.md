# Data Model: MVP Website

**Feature**: MVP Website (Landing, Dashboard, Auth)
**Date**: 2025-10-22
**Purpose**: Define database schema, entities, relationships, and validation rules

## Overview

The MVP website requires persistent storage for user accounts, authentication sessions, plan information, and usage tracking. The data model prioritizes simplicity while supporting future extensibility.

**Database**: PostgreSQL (production), SQLite (development)
**ORM**: Drizzle ORM with Drizzle Kit for migrations
**Schema Version**: 1.0.0

## Entities

### 1. User

Represents an authenticated user who has signed in via OAuth.

**Table**: `users`

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | serial | PRIMARY KEY | Auto-incrementing user ID |
| email | varchar(255) | NOT NULL, UNIQUE | User's email from OAuth provider |
| name | varchar(255) | NULL | User's display name from OAuth provider |
| provider | varchar(50) | NOT NULL | OAuth provider: "google" or "github" |
| provider_id | varchar(255) | NOT NULL | Unique ID from OAuth provider |
| plan | varchar(20) | NOT NULL, DEFAULT 'free' | User's plan: "free" or "pro" |
| created_at | timestamp | NOT NULL, DEFAULT NOW() | Account creation timestamp |
| updated_at | timestamp | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Indexes**:
- `idx_users_email` on `email` (unique constraint, fast lookup)
- `idx_users_provider_id` on `provider, provider_id` (OAuth lookup)

**Validation Rules**:
- `email`: Must be valid email format (validated by OAuth provider)
- `provider`: Must be one of: "google", "github"
- `plan`: Must be one of: "free", "pro"

**Relationships**:
- One user has many sessions (1:N)
- One user has many usage_metrics (1:N)

**Example**:
```json
{
  "id": 1,
  "email": "user@example.com",
  "name": "John Doe",
  "provider": "google",
  "provider_id": "1234567890",
  "plan": "free",
  "created_at": "2025-10-22T10:00:00Z",
  "updated_at": "2025-10-22T10:00:00Z"
}
```

---

### 2. Session

Represents an active user session (database-backed strategy).

**Table**: `sessions`

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | serial | PRIMARY KEY | Auto-incrementing session ID |
| user_id | integer | NOT NULL, FOREIGN KEY → users(id) | Reference to user |
| session_token | varchar(255) | NOT NULL, UNIQUE | Session token (hashed) |
| expires_at | timestamp | NOT NULL | Session expiry time (60 minutes from creation) |
| created_at | timestamp | NOT NULL, DEFAULT NOW() | Session creation timestamp |

**Indexes**:
- `idx_sessions_token` on `session_token` (unique constraint, fast lookup)
- `idx_sessions_user_id` on `user_id` (find all user sessions)
- `idx_sessions_expires_at` on `expires_at` (cleanup expired sessions)

**Validation Rules**:
- `expires_at`: Must be > NOW() for active sessions
- `session_token`: Must be unique, min 32 characters (generated by Auth.js)

**Lifecycle**:
- Created on successful OAuth signin
- Expires after 60 minutes (per spec FR-015)
- Deleted on signout or expiry

**Relationships**:
- Many sessions belong to one user (N:1)

**Example**:
```json
{
  "id": 1,
  "user_id": 1,
  "session_token": "a1b2c3d4e5f6...", // Hashed token
  "expires_at": "2025-10-22T11:00:00Z",
  "created_at": "2025-10-22T10:00:00Z"
}
```

**Cleanup Task**:
- Periodic job (cron or background task) to delete expired sessions:
  ```sql
  DELETE FROM sessions WHERE expires_at < NOW();
  ```

---

### 3. Plan

Represents a subscription tier (Free or Pro). This can be a static config or database table.

**Option A: Static Config** (Recommended for MVP):
```typescript
// config/plans.ts
export const plans = {
  free: {
    name: "Free",
    price: 0,
    quotaRequestsPerDay: 100,
    features: [
      "Core crypto prices (Binance adapter)",
      "Basic news (coming soon)",
      "Rate limits apply"
    ]
  },
  pro: {
    name: "Pro",
    price: null, // TBD
    quotaRequestsPerDay: 1000,
    features: [
      "Everything in Free",
      "On‑chain & social signals (rolling out)",
      "Higher limits, priority queue"
    ]
  }
} as const;
```

**Option B: Database Table** (if plans need to be dynamically updated):

**Table**: `plans`

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | serial | PRIMARY KEY | Auto-incrementing plan ID |
| name | varchar(50) | NOT NULL, UNIQUE | Plan name: "free", "pro" |
| display_name | varchar(100) | NOT NULL | Display name: "Free", "Pro" |
| price_cents | integer | NULL | Price in cents (NULL = TBD) |
| quota_requests_per_day | integer | NOT NULL | Daily request quota |
| features | jsonb | NOT NULL | Array of feature strings |
| is_active | boolean | NOT NULL, DEFAULT true | Whether plan is available |

**Decision**: Use **Option A (Static Config)** for MVP. Only 2 plans with fixed features; no dynamic pricing yet.

---

### 4. DataSource

Represents available data sources shown in the dashboard.

**Static Config** (no database table needed for MVP):
```typescript
// config/data-sources.ts
export const dataSources = [
  {
    name: "Binance Prices",
    description: "Spot price, 24h change, 24h volume",
    availability: "free",
    status: "active"
  },
  {
    name: "Crypto News (aggregated)",
    description: "Headline feed curated for crypto tickers",
    availability: "free",
    status: "planned"
  },
  {
    name: "On‑chain Metrics",
    description: "Network activity, exchange flows",
    availability: "pro",
    status: "planned"
  },
  {
    name: "Social Signals",
    description: "X/Telegram curated signals and sentiment",
    availability: "pro",
    status: "planned"
  }
] as const;
```

**Rationale**: Data sources are read-only configuration for MVP. No user customization, no dynamic updates. Static config is simpler.

---

### 5. UsageMetrics

Represents user consumption data for quota tracking.

**Table**: `usage_metrics`

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | serial | PRIMARY KEY | Auto-incrementing metric ID |
| user_id | integer | NOT NULL, FOREIGN KEY → users(id) | Reference to user |
| period_start | date | NOT NULL | Start of usage period (e.g., 2025-10-22) |
| period_end | date | NOT NULL | End of usage period (e.g., 2025-10-23) |
| request_count | integer | NOT NULL, DEFAULT 0 | Number of requests made in period |
| quota_limit | integer | NOT NULL | Quota limit for this period (denormalized for reporting) |
| reset_at | timestamp | NOT NULL | When usage counter resets |
| created_at | timestamp | NOT NULL, DEFAULT NOW() | Record creation timestamp |
| updated_at | timestamp | NOT NULL, DEFAULT NOW() | Last update timestamp |

**Indexes**:
- `idx_usage_user_period` on `user_id, period_start` (unique, fast lookup for current period)
- `idx_usage_reset_at` on `reset_at` (cleanup old metrics)

**Validation Rules**:
- `period_end`: Must be >= `period_start`
- `request_count`: Must be >= 0, <= `quota_limit` (enforced by application logic)
- `quota_limit`: Must match user's plan quota (100 for free, 1000 for pro)

**Relationships**:
- Many usage_metrics belong to one user (N:1)

**Usage Pattern**:
```typescript
// Increment usage when user makes a request
async function trackUsage(userId: number) {
  const today = new Date().toISOString().split('T')[0];
  const user = await db.query.users.findFirst({ where: eq(users.id, userId) });
  const quotaLimit = plans[user.plan].quotaRequestsPerDay;

  const metric = await db.query.usageMetrics.findFirst({
    where: and(
      eq(usageMetrics.userId, userId),
      eq(usageMetrics.periodStart, today)
    )
  });

  if (metric) {
    // Increment existing metric
    await db.update(usageMetrics)
      .set({ requestCount: metric.requestCount + 1 })
      .where(eq(usageMetrics.id, metric.id));
  } else {
    // Create new metric for today
    await db.insert(usageMetrics).values({
      userId,
      periodStart: today,
      periodEnd: addDays(today, 1),
      requestCount: 1,
      quotaLimit,
      resetAt: addDays(today, 1)
    });
  }
}
```

**Example**:
```json
{
  "id": 1,
  "user_id": 1,
  "period_start": "2025-10-22",
  "period_end": "2025-10-23",
  "request_count": 45,
  "quota_limit": 100,
  "reset_at": "2025-10-23T00:00:00Z",
  "created_at": "2025-10-22T00:00:00Z",
  "updated_at": "2025-10-22T14:30:00Z"
}
```

---

## Entity Relationship Diagram

```
┌─────────────┐
│    User     │
│─────────────│
│ id (PK)     │
│ email       │◄────┐
│ provider    │     │
│ plan        │     │
└─────────────┘     │
       │            │
       │ 1:N        │ N:1
       │            │
       ▼            │
┌─────────────┐    │
│   Session   │    │
│─────────────│    │
│ id (PK)     │    │
│ user_id (FK)├────┘
│ expires_at  │
└─────────────┘

┌─────────────┐
│    User     │
│─────────────│
│ id (PK)     │
│ plan        │◄────┐
└─────────────┘     │
       │            │
       │ 1:N        │ N:1
       │            │
       ▼            │
┌──────────────┐   │
│UsageMetrics  │   │
│──────────────│   │
│ id (PK)      │   │
│ user_id (FK) ├───┘
│ request_count│
│ quota_limit  │
└──────────────┘

Static Configs (no tables):
┌─────────────┐
│    Plan     │ (config/plans.ts)
│─────────────│
│ free        │
│ pro         │
└─────────────┘

┌─────────────┐
│ DataSource  │ (config/data-sources.ts)
│─────────────│
│ [4 sources] │
└─────────────┘
```

---

## Drizzle Schema Definition

```typescript
// lib/db/schema.ts
import { pgTable, serial, varchar, timestamp, integer, boolean, date } from "drizzle-orm/pg-core";

export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  email: varchar("email", { length: 255 }).notNull().unique(),
  name: varchar("name", { length: 255 }),
  provider: varchar("provider", { length: 50 }).notNull(),
  providerId: varchar("provider_id", { length: 255 }).notNull(),
  plan: varchar("plan", { length: 20 }).notNull().default("free"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => ({
  emailIdx: uniqueIndex("idx_users_email").on(table.email),
  providerIdx: index("idx_users_provider_id").on(table.provider, table.providerId),
}));

export const sessions = pgTable("sessions", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  sessionToken: varchar("session_token", { length: 255 }).notNull().unique(),
  expiresAt: timestamp("expires_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
}, (table) => ({
  tokenIdx: uniqueIndex("idx_sessions_token").on(table.sessionToken),
  userIdx: index("idx_sessions_user_id").on(table.userId),
  expiresIdx: index("idx_sessions_expires_at").on(table.expiresAt),
}));

export const usageMetrics = pgTable("usage_metrics", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id, { onDelete: "cascade" }).notNull(),
  periodStart: date("period_start").notNull(),
  periodEnd: date("period_end").notNull(),
  requestCount: integer("request_count").notNull().default(0),
  quotaLimit: integer("quota_limit").notNull(),
  resetAt: timestamp("reset_at").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
}, (table) => ({
  userPeriodIdx: uniqueIndex("idx_usage_user_period").on(table.userId, table.periodStart),
  resetIdx: index("idx_usage_reset_at").on(table.resetAt),
}));
```

---

## Migrations

**Initial Migration** (create tables):
```sql
-- Migration: 0001_create_users_sessions_usage.sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) NOT NULL UNIQUE,
  name VARCHAR(255),
  provider VARCHAR(50) NOT NULL,
  provider_id VARCHAR(255) NOT NULL,
  plan VARCHAR(20) NOT NULL DEFAULT 'free',
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_provider_id ON users(provider, provider_id);

CREATE TABLE sessions (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  session_token VARCHAR(255) NOT NULL UNIQUE,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_sessions_token ON sessions(session_token);
CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_expires_at ON sessions(expires_at);

CREATE TABLE usage_metrics (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  period_start DATE NOT NULL,
  period_end DATE NOT NULL,
  request_count INTEGER NOT NULL DEFAULT 0,
  quota_limit INTEGER NOT NULL,
  reset_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX idx_usage_user_period ON usage_metrics(user_id, period_start);
CREATE INDEX idx_usage_reset_at ON usage_metrics(reset_at);
```

**Run Migration**:
```bash
# Generate migration from Drizzle schema
npx drizzle-kit generate:pg

# Apply migration to database
npx drizzle-kit push:pg
```

---

## Data Validation

**Application-Level Validation** (beyond database constraints):

```typescript
// lib/validation.ts
import { z } from "zod";

export const userSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1).max(255).optional(),
  provider: z.enum(["google", "github"]),
  providerId: z.string().min(1),
  plan: z.enum(["free", "pro"]).default("free"),
});

export const sessionSchema = z.object({
  userId: z.number().int().positive(),
  sessionToken: z.string().min(32),
  expiresAt: z.date().min(new Date()), // Must be in future
});

export const usageMetricSchema = z.object({
  userId: z.number().int().positive(),
  periodStart: z.date(),
  periodEnd: z.date(),
  requestCount: z.number().int().nonnegative(),
  quotaLimit: z.number().int().positive(),
  resetAt: z.date(),
}).refine((data) => data.periodEnd >= data.periodStart, {
  message: "periodEnd must be >= periodStart",
}).refine((data) => data.requestCount <= data.quotaLimit, {
  message: "requestCount cannot exceed quotaLimit",
});
```

---

## Summary

**Tables Created**: 3 (users, sessions, usage_metrics)
**Static Configs**: 2 (plans, data-sources)
**Total Entities**: 5
**Indexes**: 8 (optimized for common queries)

**Key Design Decisions**:
- Database sessions over JWT (better security, easier revocation)
- Static plan/data-source configs (no dynamic updates needed in MVP)
- Daily usage tracking with automatic reset
- Cascade deletes for sessions/metrics when user deleted
- Drizzle ORM for type safety and performance
